---

title: Fancy Progress Bar callback for PyTorch Lightning.


keywords: fastai
sidebar: home_sidebar

summary: "This was inspired from: https://github.com/huggingface/transformers/blob/master/src/transformers/utils/notebook.py"
description: "This was inspired from: https://github.com/huggingface/transformers/blob/master/src/transformers/utils/notebook.py"
nb_path: "nbs/07a_collections.callbacks.notebook.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/07a_collections.callbacks.notebook.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%</span><span class="k">load_ext</span> nb_black
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">




<div id="d00607fe-5f68-416f-a295-5da9686de6c2"></div>
<div class="output_subarea output_javascript ">
<script type="text/javascript">
var element = $('#d00607fe-5f68-416f-a295-5da9686de6c2');

            setTimeout(function() {
                var nbb_cell_id = 2;
                var nbb_unformatted_code = "%load_ext nb_black";
                var nbb_formatted_code = "%load_ext nb_black";
                var nbb_cells = Jupyter.notebook.get_cells();
                for (var i = 0; i < nbb_cells.length; ++i) {
                    if (nbb_cells[i].input_prompt_number == nbb_cell_id) {
                        if (nbb_cells[i].get_text() == nbb_unformatted_code) {
                             nbb_cells[i].set_text(nbb_formatted_code);
                        }
                        break;
                    }
                }
            }, 500);
            
</script>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">nbdev.export</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">nbdev.export</span> <span class="kn">import</span> <span class="n">Config</span>
<span class="kn">from</span> <span class="nn">nbdev.showdoc</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">




<div id="7dec6708-b827-4f5c-916d-d3b283df3d4e"></div>
<div class="output_subarea output_javascript ">
<script type="text/javascript">
var element = $('#7dec6708-b827-4f5c-916d-d3b283df3d4e');

            setTimeout(function() {
                var nbb_cell_id = 3;
                var nbb_unformatted_code = "import warnings\n\nfrom nbdev.export import *\nfrom nbdev.export import Config\nfrom nbdev.showdoc import *\n\nwarnings.filterwarnings(\"ignore\")";
                var nbb_formatted_code = "import warnings\n\nfrom nbdev.export import *\nfrom nbdev.export import Config\nfrom nbdev.showdoc import *\n\nwarnings.filterwarnings(\"ignore\")";
                var nbb_cells = Jupyter.notebook.get_cells();
                for (var i = 0; i < nbb_cells.length; ++i) {
                    if (nbb_cells[i].input_prompt_number == nbb_cell_id) {
                        if (nbb_cells[i].get_text() == nbb_unformatted_code) {
                             nbb_cells[i].set_text(nbb_formatted_code);
                        }
                        break;
                    }
                }
            }, 500);
            
</script>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="format_time" class="doc_header"><code>format_time</code><a href="https://github.com/benihime91/gale/tree/master/gale/collections/callbacks/notebook.py#L21" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>format_time</code>(<strong><code>t</code></strong>)</p>
</blockquote>
<p>Format <code>t</code> (in seconds) to (h):mm:ss</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="html_progress_bar" class="doc_header"><code>html_progress_bar</code><a href="https://github.com/benihime91/gale/tree/master/gale/collections/callbacks/notebook.py#L28" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>html_progress_bar</code>(<strong><code>value</code></strong>, <strong><code>total</code></strong>, <strong><code>prefix</code></strong>, <strong><code>label</code></strong>, <strong><code>width</code></strong>=<em><code>300</code></em>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="text_to_html_table" class="doc_header"><code>text_to_html_table</code><a href="https://github.com/benihime91/gale/tree/master/gale/collections/callbacks/notebook.py#L45" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>text_to_html_table</code>(<strong><code>items</code></strong>)</p>
</blockquote>
<p>Put the texts in <code>items</code> in an HTML table.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="NotebookProgressBar" class="doc_header"><code>class</code> <code>NotebookProgressBar</code><a href="https://github.com/benihime91/gale/tree/master/gale/collections/callbacks/notebook.py#L62" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>NotebookProgressBar</code>(<strong><code>total</code></strong>:<code>int</code>, <strong><code>prefix</code></strong>:<code>Optional</code>[<code>str</code>]=<em><code>None</code></em>, <strong><code>leave</code></strong>:<code>bool</code>=<em><code>True</code></em>, <strong><code>parent</code></strong>:<code>Optional</code>[<code>_ForwardRef('NotebookTrainingTracker')</code>]=<em><code>None</code></em>, <strong><code>width</code></strong>:<code>int</code>=<em><code>300</code></em>)</p>
</blockquote>
<p>A progress par for display in a notebook.
Class attributes (overridden by derived classes)</p>

<pre><code>- **warmup** (:obj:`int`) -- The number of iterations to do at the beginning while ignoring
  :obj:`update_every`.
- **update_every** (:obj:`float`) -- Since calling the time takes some time, we only do it every presumed
  :obj:`update_every` seconds. The progress bar uses the average time passed up until now to guess the next
  value for which it will call the update.
</code></pre>
<p>Args:
    total (:obj:<code>int</code>):
        The total number of iterations to reach.
    prefix (:obj:<code>str</code>, <code>optional</code>):
        A prefix to add before the progress bar.
    leave (:obj:<code>bool</code>, <code>optional</code>, defaults to :obj:<code>True</code>):
        Whether or not to leave the progress bar once it's completed. You can always call the
        :meth:<code>~transformers.utils.notebook.NotebookProgressBar.close</code> method to make the bar disappear.
    parent (:class:<code>~transformers.notebook.NotebookTrainingTracker</code>, <code>optional</code>):
        A parent object (like :class:<code>~transformers.utils.notebook.NotebookTrainingTracker</code>) that spawns progress
        bars and handle their display. If set, the object passed must have a :obj:<code>display()</code> method.
    width (:obj:<code>int</code>, <code>optional</code>, defaults to 300):
        The width (in pixels) that the bar will take.
Example::
    import time
    pbar = NotebookProgressBar(100)
    for val in range(100):
        pbar.update(val)
        time.sleep(0.07)
    pbar.update(100)</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="NotebookTrainingTracker" class="doc_header"><code>class</code> <code>NotebookTrainingTracker</code><a href="https://github.com/benihime91/gale/tree/master/gale/collections/callbacks/notebook.py#L199" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>NotebookTrainingTracker</code>(<strong><code>num_steps</code></strong>, <strong><code>column_names</code></strong>=<em><code>None</code></em>, <strong><code>prefix</code></strong>=<em><code>''</code></em>) :: <a href="/gale/collections.callbacks.notebook.html#NotebookProgressBar"><code>NotebookProgressBar</code></a></p>
</blockquote>
<p>An object tracking the updates of an ongoing training with progress bars and a nice table reporting metrics.
Args:
    num_steps (:obj:<code>int</code>): The number of steps during training.
    column_names (:obj:<code>List[str]</code>, <code>optional</code>):
        The list of column names for the metrics table (will be inferred from the first call to
        :meth:<code>~transformers.utils.notebook.NotebookTrainingTracker.write_line</code> if not set).</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">




<div id="3c8bca8f-aca5-427d-bed8-6e7f91cb3442"></div>
<div class="output_subarea output_javascript ">
<script type="text/javascript">
var element = $('#3c8bca8f-aca5-427d-bed8-6e7f91cb3442');

            setTimeout(function() {
                var nbb_cell_id = 5;
                var nbb_unformatted_code = "# export\n##################################################################################################################\n# Straight copy from : https://github.com/huggingface/transformers/blob/master/src/transformers/utils/notebook.py\n###################################################################################################################\n\n\ndef format_time(t):\n    \"Format `t` (in seconds) to (h):mm:ss\"\n    t = int(t)\n    h, m, s = t // 3600, (t // 60) % 60, t % 60\n    return f\"{h}:{m:02d}:{s:02d}\" if h != 0 else f\"{m:02d}:{s:02d}\"\n\n\ndef html_progress_bar(value, total, prefix, label, width=300):\n    # docstyle-ignore\n    return f\"\"\"\n    <div>\n        <style>\n            progress {{\n                border: none;\n                background-size: auto;\n            }}\n        </style>\n      {prefix}\n      <progress value='{value}' max='{total}' style='width:{width}px; height:20px; vertical-align: middle;'></progress>\n      {label}\n    </div>\n    \"\"\"\n\n\ndef text_to_html_table(items):\n    \"Put the texts in `items` in an HTML table.\"\n    html_code = \"\"\"<table border=\"1\" class=\"dataframe\">\\n\"\"\"\n    html_code += \"\"\"  <thead>\\n    <tr style=\"text-align: left;\">\\n\"\"\"\n    for i in items[0]:\n        html_code += f\"      <th>{i}</th>\\n\"\n    html_code += \"    </tr>\\n  </thead>\\n  <tbody>\\n\"\n    for line in items[1:]:\n        html_code += \"    <tr>\\n\"\n        for elt in line:\n            elt = f\"{elt:.6f}\" if isinstance(elt, float) else str(elt)\n            html_code += f\"      <td>{elt}</td>\\n\"\n        html_code += \"    </tr>\\n\"\n    html_code += \"  </tbody>\\n</table><p>\"\n    return html_code\n\n\nclass NotebookProgressBar:\n    \"\"\"\n    A progress par for display in a notebook.\n    Class attributes (overridden by derived classes)\n        - **warmup** (:obj:`int`) -- The number of iterations to do at the beginning while ignoring\n          :obj:`update_every`.\n        - **update_every** (:obj:`float`) -- Since calling the time takes some time, we only do it every presumed\n          :obj:`update_every` seconds. The progress bar uses the average time passed up until now to guess the next\n          value for which it will call the update.\n    Args:\n        total (:obj:`int`):\n            The total number of iterations to reach.\n        prefix (:obj:`str`, `optional`):\n            A prefix to add before the progress bar.\n        leave (:obj:`bool`, `optional`, defaults to :obj:`True`):\n            Whether or not to leave the progress bar once it's completed. You can always call the\n            :meth:`~transformers.utils.notebook.NotebookProgressBar.close` method to make the bar disappear.\n        parent (:class:`~transformers.notebook.NotebookTrainingTracker`, `optional`):\n            A parent object (like :class:`~transformers.utils.notebook.NotebookTrainingTracker`) that spawns progress\n            bars and handle their display. If set, the object passed must have a :obj:`display()` method.\n        width (:obj:`int`, `optional`, defaults to 300):\n            The width (in pixels) that the bar will take.\n    Example::\n        import time\n        pbar = NotebookProgressBar(100)\n        for val in range(100):\n            pbar.update(val)\n            time.sleep(0.07)\n        pbar.update(100)\n    \"\"\"\n\n    warmup = 5\n    update_every = 0.2\n\n    def __init__(\n        self,\n        total: int,\n        prefix: Optional[str] = None,\n        leave: bool = True,\n        parent: Optional[\"NotebookTrainingTracker\"] = None,\n        width: int = 300,\n    ):\n        self.total = total\n        self.prefix = \"\" if prefix is None else prefix\n        self.leave = leave\n        self.parent = parent\n        self.width = width\n        self.last_value = None\n        self.comment = None\n        self.output = None\n\n    def update(self, value: int, force_update: bool = False, comment: str = None):\n        \"\"\"\n        The main method to update the progress bar to :obj:`value`.\n        Args:\n            value (:obj:`int`):\n                The value to use. Must be between 0 and :obj:`total`.\n            force_update (:obj:`bool`, `optional`, defaults to :obj:`False`):\n                Whether or not to force and update of the internal state and display (by default, the bar will wait for\n                :obj:`value` to reach the value it predicted corresponds to a time of more than the :obj:`update_every`\n                attribute since the last update to avoid adding boilerplate).\n            comment (:obj:`str`, `optional`):\n                A comment to add on the left of the progress bar.\n        \"\"\"\n        self.value = value\n        if comment is not None:\n            self.comment = comment\n        if self.last_value is None:\n            self.start_time = self.last_time = time.time()\n            self.start_value = self.last_value = value\n            self.elapsed_time = self.predicted_remaining = None\n            self.first_calls = self.warmup\n            self.wait_for = 1\n            self.update_bar(value)\n        elif value <= self.last_value and not force_update:\n            return\n        elif (\n            force_update\n            or self.first_calls > 0\n            or value >= min(self.last_value + self.wait_for, self.total)\n        ):\n            if self.first_calls > 0:\n                self.first_calls -= 1\n            current_time = time.time()\n            self.elapsed_time = current_time - self.start_time\n            self.average_time_per_item = self.elapsed_time / (value - self.start_value)\n            if value >= self.total:\n                value = self.total\n                self.predicted_remaining = None\n                if not self.leave:\n                    self.close()\n            else:\n                self.predicted_remaining = self.average_time_per_item * (\n                    self.total - value\n                )\n            self.update_bar(value)\n            self.last_value = value\n            self.last_time = current_time\n            self.wait_for = max(int(self.update_every / self.average_time_per_item), 1)\n\n    def update_bar(self, value, comment=None):\n        spaced_value = \" \" * (len(str(self.total)) - len(str(value))) + str(value)\n        if self.elapsed_time is None:\n            self.label = f\"[{spaced_value}/{self.total} : < :\"\n        elif self.predicted_remaining is None:\n            self.label = (\n                f\"[{spaced_value}/{self.total} {format_time(self.elapsed_time)}\"\n            )\n        else:\n            self.label = f\"[{spaced_value}/{self.total} {format_time(self.elapsed_time)} < {format_time(self.predicted_remaining)}\"\n            self.label += f\", {1/self.average_time_per_item:.2f} it/s\"\n        self.label += (\n            \"]\"\n            if self.comment is None or len(self.comment) == 0\n            else f\", {self.comment}]\"\n        )\n        self.display()\n\n    def display(self):\n        self.html_code = html_progress_bar(\n            self.value, self.total, self.prefix, self.label, self.width\n        )\n        if self.parent is not None:\n            # If this is a child bar, the parent will take care of the display.\n            self.parent.display()\n            return\n        if self.output is None:\n            self.output = disp.display(disp.HTML(self.html_code), display_id=True)\n        else:\n            self.output.update(disp.HTML(self.html_code))\n\n    def close(self):\n        \"Closes the progress bar.\"\n        if self.parent is None and self.output is not None:\n            self.output.update(disp.HTML(\"\"))\n\n\nclass NotebookTrainingTracker(NotebookProgressBar):\n    \"\"\"\n    An object tracking the updates of an ongoing training with progress bars and a nice table reporting metrics.\n    Args:\n        num_steps (:obj:`int`): The number of steps during training.\n        column_names (:obj:`List[str]`, `optional`):\n            The list of column names for the metrics table (will be inferred from the first call to\n            :meth:`~transformers.utils.notebook.NotebookTrainingTracker.write_line` if not set).\n    \"\"\"\n\n    def __init__(self, num_steps, column_names=None, prefix=\"\"):\n        super().__init__(num_steps)\n        self.inner_table = None if column_names is None else [column_names]\n        self.child_bar = None\n        self.prefix = prefix\n\n    def display(self):\n        self.html_code = html_progress_bar(\n            self.value, self.total, self.prefix, self.label, self.width\n        )\n        if self.inner_table is not None:\n            self.html_code += text_to_html_table(self.inner_table)\n        if self.child_bar is not None:\n            self.html_code += self.child_bar.html_code\n        if self.output is None:\n            self.output = disp.display(disp.HTML(self.html_code), display_id=True)\n        else:\n            self.output.update(disp.HTML(self.html_code))\n\n    def write_line(self, values):\n        \"\"\"\n        Write the values in the inner table.\n        Args:\n            values (:obj:`Dict[str, float]`): The values to display.\n        \"\"\"\n        if self.inner_table is None:\n            self.inner_table = [list(values.keys()), list(values.values())]\n        else:\n            columns = self.inner_table[0]\n            if len(self.inner_table) == 1:\n                # We give a chance to update the column names at the first iteration\n                for key in values.keys():\n                    if key not in columns:\n                        columns.append(key)\n                self.inner_table[0] = columns\n            self.inner_table.append([values[c] for c in columns])\n\n    def add_child(self, total, prefix=None, width=300):\n        \"\"\"\n        Add a child progress bar displayed under the table of metrics. The child progress bar is returned (so it can be\n        easily updated).\n        Args:\n            total (:obj:`int`): The number of iterations for the child progress bar.\n            prefix (:obj:`str`, `optional`): A prefix to write on the left of the progress bar.\n            width (:obj:`int`, `optional`, defaults to 300): The width (in pixels) of the progress bar.\n        \"\"\"\n        self.child_bar = NotebookProgressBar(\n            total, prefix=prefix, parent=self, width=width\n        )\n        return self.child_bar\n\n    def remove_child(self):\n        \"\"\"\n        Closes the child progress bar.\n        \"\"\"\n        self.child_bar = None\n        self.display()\n\n\n##################################################################################################################\n# End of copy\n###################################################################################################################";
                var nbb_formatted_code = "# export\n##################################################################################################################\n# Straight copy from : https://github.com/huggingface/transformers/blob/master/src/transformers/utils/notebook.py\n###################################################################################################################\n\n\ndef format_time(t):\n    \"Format `t` (in seconds) to (h):mm:ss\"\n    t = int(t)\n    h, m, s = t // 3600, (t // 60) % 60, t % 60\n    return f\"{h}:{m:02d}:{s:02d}\" if h != 0 else f\"{m:02d}:{s:02d}\"\n\n\ndef html_progress_bar(value, total, prefix, label, width=300):\n    # docstyle-ignore\n    return f\"\"\"\n    <div>\n        <style>\n            progress {{\n                border: none;\n                background-size: auto;\n            }}\n        </style>\n      {prefix}\n      <progress value='{value}' max='{total}' style='width:{width}px; height:20px; vertical-align: middle;'></progress>\n      {label}\n    </div>\n    \"\"\"\n\n\ndef text_to_html_table(items):\n    \"Put the texts in `items` in an HTML table.\"\n    html_code = \"\"\"<table border=\"1\" class=\"dataframe\">\\n\"\"\"\n    html_code += \"\"\"  <thead>\\n    <tr style=\"text-align: left;\">\\n\"\"\"\n    for i in items[0]:\n        html_code += f\"      <th>{i}</th>\\n\"\n    html_code += \"    </tr>\\n  </thead>\\n  <tbody>\\n\"\n    for line in items[1:]:\n        html_code += \"    <tr>\\n\"\n        for elt in line:\n            elt = f\"{elt:.6f}\" if isinstance(elt, float) else str(elt)\n            html_code += f\"      <td>{elt}</td>\\n\"\n        html_code += \"    </tr>\\n\"\n    html_code += \"  </tbody>\\n</table><p>\"\n    return html_code\n\n\nclass NotebookProgressBar:\n    \"\"\"\n    A progress par for display in a notebook.\n    Class attributes (overridden by derived classes)\n        - **warmup** (:obj:`int`) -- The number of iterations to do at the beginning while ignoring\n          :obj:`update_every`.\n        - **update_every** (:obj:`float`) -- Since calling the time takes some time, we only do it every presumed\n          :obj:`update_every` seconds. The progress bar uses the average time passed up until now to guess the next\n          value for which it will call the update.\n    Args:\n        total (:obj:`int`):\n            The total number of iterations to reach.\n        prefix (:obj:`str`, `optional`):\n            A prefix to add before the progress bar.\n        leave (:obj:`bool`, `optional`, defaults to :obj:`True`):\n            Whether or not to leave the progress bar once it's completed. You can always call the\n            :meth:`~transformers.utils.notebook.NotebookProgressBar.close` method to make the bar disappear.\n        parent (:class:`~transformers.notebook.NotebookTrainingTracker`, `optional`):\n            A parent object (like :class:`~transformers.utils.notebook.NotebookTrainingTracker`) that spawns progress\n            bars and handle their display. If set, the object passed must have a :obj:`display()` method.\n        width (:obj:`int`, `optional`, defaults to 300):\n            The width (in pixels) that the bar will take.\n    Example::\n        import time\n        pbar = NotebookProgressBar(100)\n        for val in range(100):\n            pbar.update(val)\n            time.sleep(0.07)\n        pbar.update(100)\n    \"\"\"\n\n    warmup = 5\n    update_every = 0.2\n\n    def __init__(\n        self,\n        total: int,\n        prefix: Optional[str] = None,\n        leave: bool = True,\n        parent: Optional[\"NotebookTrainingTracker\"] = None,\n        width: int = 300,\n    ):\n        self.total = total\n        self.prefix = \"\" if prefix is None else prefix\n        self.leave = leave\n        self.parent = parent\n        self.width = width\n        self.last_value = None\n        self.comment = None\n        self.output = None\n\n    def update(self, value: int, force_update: bool = False, comment: str = None):\n        \"\"\"\n        The main method to update the progress bar to :obj:`value`.\n        Args:\n            value (:obj:`int`):\n                The value to use. Must be between 0 and :obj:`total`.\n            force_update (:obj:`bool`, `optional`, defaults to :obj:`False`):\n                Whether or not to force and update of the internal state and display (by default, the bar will wait for\n                :obj:`value` to reach the value it predicted corresponds to a time of more than the :obj:`update_every`\n                attribute since the last update to avoid adding boilerplate).\n            comment (:obj:`str`, `optional`):\n                A comment to add on the left of the progress bar.\n        \"\"\"\n        self.value = value\n        if comment is not None:\n            self.comment = comment\n        if self.last_value is None:\n            self.start_time = self.last_time = time.time()\n            self.start_value = self.last_value = value\n            self.elapsed_time = self.predicted_remaining = None\n            self.first_calls = self.warmup\n            self.wait_for = 1\n            self.update_bar(value)\n        elif value <= self.last_value and not force_update:\n            return\n        elif (\n            force_update\n            or self.first_calls > 0\n            or value >= min(self.last_value + self.wait_for, self.total)\n        ):\n            if self.first_calls > 0:\n                self.first_calls -= 1\n            current_time = time.time()\n            self.elapsed_time = current_time - self.start_time\n            self.average_time_per_item = self.elapsed_time / (value - self.start_value)\n            if value >= self.total:\n                value = self.total\n                self.predicted_remaining = None\n                if not self.leave:\n                    self.close()\n            else:\n                self.predicted_remaining = self.average_time_per_item * (\n                    self.total - value\n                )\n            self.update_bar(value)\n            self.last_value = value\n            self.last_time = current_time\n            self.wait_for = max(int(self.update_every / self.average_time_per_item), 1)\n\n    def update_bar(self, value, comment=None):\n        spaced_value = \" \" * (len(str(self.total)) - len(str(value))) + str(value)\n        if self.elapsed_time is None:\n            self.label = f\"[{spaced_value}/{self.total} : < :\"\n        elif self.predicted_remaining is None:\n            self.label = (\n                f\"[{spaced_value}/{self.total} {format_time(self.elapsed_time)}\"\n            )\n        else:\n            self.label = f\"[{spaced_value}/{self.total} {format_time(self.elapsed_time)} < {format_time(self.predicted_remaining)}\"\n            self.label += f\", {1/self.average_time_per_item:.2f} it/s\"\n        self.label += (\n            \"]\"\n            if self.comment is None or len(self.comment) == 0\n            else f\", {self.comment}]\"\n        )\n        self.display()\n\n    def display(self):\n        self.html_code = html_progress_bar(\n            self.value, self.total, self.prefix, self.label, self.width\n        )\n        if self.parent is not None:\n            # If this is a child bar, the parent will take care of the display.\n            self.parent.display()\n            return\n        if self.output is None:\n            self.output = disp.display(disp.HTML(self.html_code), display_id=True)\n        else:\n            self.output.update(disp.HTML(self.html_code))\n\n    def close(self):\n        \"Closes the progress bar.\"\n        if self.parent is None and self.output is not None:\n            self.output.update(disp.HTML(\"\"))\n\n\nclass NotebookTrainingTracker(NotebookProgressBar):\n    \"\"\"\n    An object tracking the updates of an ongoing training with progress bars and a nice table reporting metrics.\n    Args:\n        num_steps (:obj:`int`): The number of steps during training.\n        column_names (:obj:`List[str]`, `optional`):\n            The list of column names for the metrics table (will be inferred from the first call to\n            :meth:`~transformers.utils.notebook.NotebookTrainingTracker.write_line` if not set).\n    \"\"\"\n\n    def __init__(self, num_steps, column_names=None, prefix=\"\"):\n        super().__init__(num_steps)\n        self.inner_table = None if column_names is None else [column_names]\n        self.child_bar = None\n        self.prefix = prefix\n\n    def display(self):\n        self.html_code = html_progress_bar(\n            self.value, self.total, self.prefix, self.label, self.width\n        )\n        if self.inner_table is not None:\n            self.html_code += text_to_html_table(self.inner_table)\n        if self.child_bar is not None:\n            self.html_code += self.child_bar.html_code\n        if self.output is None:\n            self.output = disp.display(disp.HTML(self.html_code), display_id=True)\n        else:\n            self.output.update(disp.HTML(self.html_code))\n\n    def write_line(self, values):\n        \"\"\"\n        Write the values in the inner table.\n        Args:\n            values (:obj:`Dict[str, float]`): The values to display.\n        \"\"\"\n        if self.inner_table is None:\n            self.inner_table = [list(values.keys()), list(values.values())]\n        else:\n            columns = self.inner_table[0]\n            if len(self.inner_table) == 1:\n                # We give a chance to update the column names at the first iteration\n                for key in values.keys():\n                    if key not in columns:\n                        columns.append(key)\n                self.inner_table[0] = columns\n            self.inner_table.append([values[c] for c in columns])\n\n    def add_child(self, total, prefix=None, width=300):\n        \"\"\"\n        Add a child progress bar displayed under the table of metrics. The child progress bar is returned (so it can be\n        easily updated).\n        Args:\n            total (:obj:`int`): The number of iterations for the child progress bar.\n            prefix (:obj:`str`, `optional`): A prefix to write on the left of the progress bar.\n            width (:obj:`int`, `optional`, defaults to 300): The width (in pixels) of the progress bar.\n        \"\"\"\n        self.child_bar = NotebookProgressBar(\n            total, prefix=prefix, parent=self, width=width\n        )\n        return self.child_bar\n\n    def remove_child(self):\n        \"\"\"\n        Closes the child progress bar.\n        \"\"\"\n        self.child_bar = None\n        self.display()\n\n\n##################################################################################################################\n# End of copy\n###################################################################################################################";
                var nbb_cells = Jupyter.notebook.get_cells();
                for (var i = 0; i < nbb_cells.length; ++i) {
                    if (nbb_cells[i].input_prompt_number == nbb_cell_id) {
                        if (nbb_cells[i].get_text() == nbb_unformatted_code) {
                             nbb_cells[i].set_text(nbb_formatted_code);
                        }
                        break;
                    }
                }
            }, 500);
            
</script>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="NotebookProgressCallback" class="doc_header"><code>class</code> <code>NotebookProgressCallback</code><a href="https://github.com/benihime91/gale/tree/master/gale/collections/callbacks/notebook.py#L273" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>NotebookProgressCallback</code>() :: <code>ProgressBarBase</code></p>
</blockquote>
<p>A progress par for display in a notebook.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">




<div id="63844d31-bfbf-490d-a396-a99f5c38432d"></div>
<div class="output_subarea output_javascript ">
<script type="text/javascript">
var element = $('#63844d31-bfbf-490d-a396-a99f5c38432d');

            setTimeout(function() {
                var nbb_cell_id = 6;
                var nbb_unformatted_code = "# export\nclass NotebookProgressCallback(ProgressBarBase):\n    \"\"\"\n    A progress par for display in a notebook.\n    \"\"\"\n    _enabled = True\n\n    def __init__(self):\n        super().__init__()\n        self._force_next_update = False\n        self.training_tracker = None\n        self.prediction_bar = None\n\n    def on_sanity_check_start(self, trainer, pl_module):\n        super().on_sanity_check_start(trainer, pl_module)\n        # dummy progress bar\n        self.prediction_bar = NotebookProgressBar(\n            int(trainer.num_sanity_val_steps), prefix=\"Validation sanity check\"\n        )\n\n    def on_sanity_check_end(self, trainer, pl_module):\n        super().on_sanity_check_end(trainer, pl_module)\n        # remove bars\n        self.prediction_bar.update(1)\n        self.prediction_bar.close()\n        self.training_tracker = None\n        self.prediction_bar = None\n\n    def on_train_start(self, trainer, pl_module):\n        super().on_train_epoch_start(trainer, pl_module)\n        self.first_column = \"Epoch\"\n        steps = trainer.max_steps or int(self.total_train_batches * trainer.max_epochs)\n        self.training_tracker = NotebookTrainingTracker(steps, prefix=\"Training\")\n\n    def on_train_epoch_start(self, trainer, pl_module):\n        super().on_train_epoch_start(trainer, pl_module)\n        self.start_time = time.time()\n\n    def on_train_batch_end(\n        self, trainer, pl_module, outputs, batch, batch_idx, dataloader_idx\n    ):\n        super().on_train_batch_end(\n            trainer, pl_module, outputs, batch, batch_idx, dataloader_idx\n        )\n        prog_dict = self._format_prog_bar_dict(trainer.progress_bar_dict)\n        comment = f\"Epoch {int(trainer.current_epoch)} {prog_dict}\"\n        step = trainer.global_step + 1\n        self.training_tracker.update(\n            step,\n            comment=comment,\n            force_update=self._force_next_update,\n        )\n        self._force_next_update = False\n\n    def on_validation_start(self, trainer, pl_module):\n        super().on_validation_start(trainer, pl_module)\n        if not trainer.running_sanity_check:\n            if self.prediction_bar is None:\n                if self.training_tracker is not None:\n                    self.prediction_bar = self.training_tracker.add_child(\n                        self.total_val_batches, prefix=\"Validating\"\n                    )\n        self.prediction_bar.update(1)\n\n    def on_validation_batch_end(\n        self, trainer, pl_module, outputs, batch, batch_idx, dataloader_idx\n    ):\n        super().on_validation_batch_end(\n            trainer, pl_module, outputs, batch, batch_idx, dataloader_idx\n        )\n        self.prediction_bar.update(self.prediction_bar.value + 1)\n\n    def on_validation_end(self, trainer, pl_module):\n        super().on_validation_end(trainer, pl_module)\n        total_train_batches = self.total_train_batches\n        metrics = trainer.callback_metrics\n        values = {}\n        values[\"epoch\"] = trainer.current_epoch\n\n        if self.training_tracker is not None:\n            for k, v in metrics.items():\n                name = str(k)\n                if isinstance(v, torch.Tensor):\n                    values[name] = v.data.cpu().numpy().item()\n                else:\n                    values[name] = v\n\n            if total_train_batches != float(\"inf\"):\n                # Measure speed performance metrics.\n                runtime = time.time() - self.start_time  # seconds\n                total_val_batches = self.total_val_batches\n                n_obs = total_train_batches + total_val_batches\n                samples_per_second = 1 / (runtime / n_obs)\n\n                values[\"time\"] = round(runtime, 4)\n                values[\"samples/s\"] = round(samples_per_second, 4)\n\n            self.training_tracker.write_line(values)\n            self.training_tracker.remove_child()\n            self.prediction_bar = None\n            self._force_next_update = True\n\n    def on_train_epoch_end(self, trainer, pl_module, outputs: Any) -> None:\n        super().on_train_epoch_end(trainer, pl_module, outputs)\n        if trainer.val_dataloaders is None:\n            self.on_validation_end(trainer, pl_module)\n\n    def on_train_end(self, trainer, pl_module):\n        super().on_train_end(trainer, pl_module)\n        self.training_tracker.update(trainer.global_step, force_update=True)\n        self.training_tracker = None\n\n    def on_test_start(self, trainer, pl_module):\n        super().on_test_start(trainer, pl_module)\n        self.test_progress_bar = NotebookProgressBar(\n            int(self.total_test_batches), prefix=\"Testing\"\n        )\n        self.test_progress_bar.update(1)\n\n    def on_test_batch_end(\n        self, trainer, pl_module, outputs, batch, batch_idx, dataloader_idx\n    ):\n        super().on_test_batch_end(\n            trainer, pl_module, outputs, batch, batch_idx, dataloader_idx\n        )\n        self.test_progress_bar.update(self.test_progress_bar.value + 1)\n\n    def on_test_end(self, trainer, pl_module):\n        super().on_test_end(trainer, pl_module)\n        self.test_progress_bar.close()\n\n    def on_predict_start(self, trainer, pl_module):\n        super().on_predict_start(trainer, pl_module)\n        self.predict_progress_bar = NotebookProgressBar(\n            int(self.total_test_batches), prefix=\"Testing\"\n        )\n        self.predict_progress_bar.update(1)\n\n    def on_predict_batch_end(\n        self, trainer, pl_module, outputs, batch, batch_idx, dataloader_idx\n    ):\n        super().on_predict_batch_end(\n            trainer, pl_module, outputs, batch, batch_idx, dataloader_idx\n        )\n        self.predict_progress_bar.update(self.test_progress_bar.value + 1)\n\n    def on_predict_end(self, trainer, pl_module):\n        self.predict_progress_bar.close()\n\n    @staticmethod\n    def _format_prog_bar_dict(progbar_dict: dict):\n        vals = {}\n        for k, v in progbar_dict.items():\n            if isinstance(v, torch.Tensor):\n                v = round(v.data.cpu().numpy().item(), 4)\n            elif isinstance(v, str):\n                pass\n            else:\n                v = round(v, 3)\n            vals[k] = v\n        return vals\n\n    @property\n    def is_enabled(self) -> bool:\n        return self._enabled\n\n    @property\n    def is_disabled(self) -> bool:\n        return not self.is_enabled\n\n    def disable(self) -> None:\n        self._enabled = False\n\n    def enable(self) -> None:\n        self._enabled = True";
                var nbb_formatted_code = "# export\nclass NotebookProgressCallback(ProgressBarBase):\n    \"\"\"\n    A progress par for display in a notebook.\n    \"\"\"\n\n    _enabled = True\n\n    def __init__(self):\n        super().__init__()\n        self._force_next_update = False\n        self.training_tracker = None\n        self.prediction_bar = None\n\n    def on_sanity_check_start(self, trainer, pl_module):\n        super().on_sanity_check_start(trainer, pl_module)\n        # dummy progress bar\n        self.prediction_bar = NotebookProgressBar(\n            int(trainer.num_sanity_val_steps), prefix=\"Validation sanity check\"\n        )\n\n    def on_sanity_check_end(self, trainer, pl_module):\n        super().on_sanity_check_end(trainer, pl_module)\n        # remove bars\n        self.prediction_bar.update(1)\n        self.prediction_bar.close()\n        self.training_tracker = None\n        self.prediction_bar = None\n\n    def on_train_start(self, trainer, pl_module):\n        super().on_train_epoch_start(trainer, pl_module)\n        self.first_column = \"Epoch\"\n        steps = trainer.max_steps or int(self.total_train_batches * trainer.max_epochs)\n        self.training_tracker = NotebookTrainingTracker(steps, prefix=\"Training\")\n\n    def on_train_epoch_start(self, trainer, pl_module):\n        super().on_train_epoch_start(trainer, pl_module)\n        self.start_time = time.time()\n\n    def on_train_batch_end(\n        self, trainer, pl_module, outputs, batch, batch_idx, dataloader_idx\n    ):\n        super().on_train_batch_end(\n            trainer, pl_module, outputs, batch, batch_idx, dataloader_idx\n        )\n        prog_dict = self._format_prog_bar_dict(trainer.progress_bar_dict)\n        comment = f\"Epoch {int(trainer.current_epoch)} {prog_dict}\"\n        step = trainer.global_step + 1\n        self.training_tracker.update(\n            step,\n            comment=comment,\n            force_update=self._force_next_update,\n        )\n        self._force_next_update = False\n\n    def on_validation_start(self, trainer, pl_module):\n        super().on_validation_start(trainer, pl_module)\n        if not trainer.running_sanity_check:\n            if self.prediction_bar is None:\n                if self.training_tracker is not None:\n                    self.prediction_bar = self.training_tracker.add_child(\n                        self.total_val_batches, prefix=\"Validating\"\n                    )\n        self.prediction_bar.update(1)\n\n    def on_validation_batch_end(\n        self, trainer, pl_module, outputs, batch, batch_idx, dataloader_idx\n    ):\n        super().on_validation_batch_end(\n            trainer, pl_module, outputs, batch, batch_idx, dataloader_idx\n        )\n        self.prediction_bar.update(self.prediction_bar.value + 1)\n\n    def on_validation_end(self, trainer, pl_module):\n        super().on_validation_end(trainer, pl_module)\n        total_train_batches = self.total_train_batches\n        metrics = trainer.callback_metrics\n        values = {}\n        values[\"epoch\"] = trainer.current_epoch\n\n        if self.training_tracker is not None:\n            for k, v in metrics.items():\n                name = str(k)\n                if isinstance(v, torch.Tensor):\n                    values[name] = v.data.cpu().numpy().item()\n                else:\n                    values[name] = v\n\n            if total_train_batches != float(\"inf\"):\n                # Measure speed performance metrics.\n                runtime = time.time() - self.start_time  # seconds\n                total_val_batches = self.total_val_batches\n                n_obs = total_train_batches + total_val_batches\n                samples_per_second = 1 / (runtime / n_obs)\n\n                values[\"time\"] = round(runtime, 4)\n                values[\"samples/s\"] = round(samples_per_second, 4)\n\n            self.training_tracker.write_line(values)\n            self.training_tracker.remove_child()\n            self.prediction_bar = None\n            self._force_next_update = True\n\n    def on_train_epoch_end(self, trainer, pl_module, outputs: Any) -> None:\n        super().on_train_epoch_end(trainer, pl_module, outputs)\n        if trainer.val_dataloaders is None:\n            self.on_validation_end(trainer, pl_module)\n\n    def on_train_end(self, trainer, pl_module):\n        super().on_train_end(trainer, pl_module)\n        self.training_tracker.update(trainer.global_step, force_update=True)\n        self.training_tracker = None\n\n    def on_test_start(self, trainer, pl_module):\n        super().on_test_start(trainer, pl_module)\n        self.test_progress_bar = NotebookProgressBar(\n            int(self.total_test_batches), prefix=\"Testing\"\n        )\n        self.test_progress_bar.update(1)\n\n    def on_test_batch_end(\n        self, trainer, pl_module, outputs, batch, batch_idx, dataloader_idx\n    ):\n        super().on_test_batch_end(\n            trainer, pl_module, outputs, batch, batch_idx, dataloader_idx\n        )\n        self.test_progress_bar.update(self.test_progress_bar.value + 1)\n\n    def on_test_end(self, trainer, pl_module):\n        super().on_test_end(trainer, pl_module)\n        self.test_progress_bar.close()\n\n    def on_predict_start(self, trainer, pl_module):\n        super().on_predict_start(trainer, pl_module)\n        self.predict_progress_bar = NotebookProgressBar(\n            int(self.total_test_batches), prefix=\"Testing\"\n        )\n        self.predict_progress_bar.update(1)\n\n    def on_predict_batch_end(\n        self, trainer, pl_module, outputs, batch, batch_idx, dataloader_idx\n    ):\n        super().on_predict_batch_end(\n            trainer, pl_module, outputs, batch, batch_idx, dataloader_idx\n        )\n        self.predict_progress_bar.update(self.test_progress_bar.value + 1)\n\n    def on_predict_end(self, trainer, pl_module):\n        self.predict_progress_bar.close()\n\n    @staticmethod\n    def _format_prog_bar_dict(progbar_dict: dict):\n        vals = {}\n        for k, v in progbar_dict.items():\n            if isinstance(v, torch.Tensor):\n                v = round(v.data.cpu().numpy().item(), 4)\n            elif isinstance(v, str):\n                pass\n            else:\n                v = round(v, 3)\n            vals[k] = v\n        return vals\n\n    @property\n    def is_enabled(self) -> bool:\n        return self._enabled\n\n    @property\n    def is_disabled(self) -> bool:\n        return not self.is_enabled\n\n    def disable(self) -> None:\n        self._enabled = False\n\n    def enable(self) -> None:\n        self._enabled = True";
                var nbb_cells = Jupyter.notebook.get_cells();
                for (var i = 0; i < nbb_cells.length; ++i) {
                    if (nbb_cells[i].input_prompt_number == nbb_cell_id) {
                        if (nbb_cells[i].get_text() == nbb_unformatted_code) {
                             nbb_cells[i].set_text(nbb_formatted_code);
                        }
                        break;
                    }
                }
            }, 500);
            
</script>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Usage">Usage<a class="anchor-link" href="#Usage"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>

<span class="kn">import</span> <span class="nn">pytorch_lightning</span> <span class="k">as</span> <span class="nn">pl</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">fastcore.all</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">torch.nn</span> <span class="kn">import</span> <span class="n">functional</span> <span class="k">as</span> <span class="n">F</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">DataLoader</span>
<span class="kn">from</span> <span class="nn">torchmetrics</span> <span class="kn">import</span> <span class="n">Accuracy</span>
<span class="kn">from</span> <span class="nn">torchvision</span> <span class="kn">import</span> <span class="n">transforms</span>
<span class="kn">from</span> <span class="nn">torchvision.datasets</span> <span class="kn">import</span> <span class="n">FashionMNIST</span>

<span class="n">source</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">Config</span><span class="p">()</span><span class="o">.</span><span class="n">path</span><span class="p">(</span><span class="s2">&quot;nbs_path&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="s2">&quot;data&quot;</span>
<span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># fmt: off</span>

<span class="c1"># data</span>
<span class="n">mnist_train</span> <span class="o">=</span> <span class="n">FashionMNIST</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">train</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">download</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">())</span>
<span class="n">mnist_train</span> <span class="o">=</span> <span class="n">DataLoader</span><span class="p">(</span><span class="n">mnist_train</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">num_workers</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

<span class="n">mnist_val</span> <span class="o">=</span> <span class="n">FashionMNIST</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">train</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">download</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">())</span>
<span class="n">mnist_val</span> <span class="o">=</span> <span class="n">DataLoader</span><span class="p">(</span><span class="n">mnist_val</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">num_workers</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">




<div id="4ba39c44-c1d8-42d7-8ce6-8efccaa9af73"></div>
<div class="output_subarea output_javascript ">
<script type="text/javascript">
var element = $('#4ba39c44-c1d8-42d7-8ce6-8efccaa9af73');

            setTimeout(function() {
                var nbb_cell_id = 9;
                var nbb_unformatted_code = "# slow\nimport os\n\nimport pytorch_lightning as pl\nimport torch\nfrom fastcore.all import Path\nfrom torch.nn import functional as F\nfrom torch.utils.data import DataLoader\nfrom torchmetrics import Accuracy\nfrom torchvision import transforms\nfrom torchvision.datasets import FashionMNIST\n\nsource = Path(Config().path(\"nbs_path\")) / \"data\"\nos.makedirs(source, exist_ok=True)\n\n# fmt: off\n\n# data\nmnist_train = FashionMNIST(source, train=True, download=True, transform=transforms.ToTensor())\nmnist_train = DataLoader(mnist_train, batch_size=32, num_workers=4)\n\nmnist_val = FashionMNIST(source, train=False, download=True, transform=transforms.ToTensor())\nmnist_val = DataLoader(mnist_val, batch_size=32, num_workers=4)";
                var nbb_formatted_code = "# slow\nimport os\n\nimport pytorch_lightning as pl\nimport torch\nfrom fastcore.all import Path\nfrom torch.nn import functional as F\nfrom torch.utils.data import DataLoader\nfrom torchmetrics import Accuracy\nfrom torchvision import transforms\nfrom torchvision.datasets import FashionMNIST\n\nsource = Path(Config().path(\"nbs_path\")) / \"data\"\nos.makedirs(source, exist_ok=True)\n\n# fmt: off\n\n# data\nmnist_train = FashionMNIST(source, train=True, download=True, transform=transforms.ToTensor())\nmnist_train = DataLoader(mnist_train, batch_size=32, num_workers=4)\n\nmnist_val = FashionMNIST(source, train=False, download=True, transform=transforms.ToTensor())\nmnist_val = DataLoader(mnist_val, batch_size=32, num_workers=4)";
                var nbb_cells = Jupyter.notebook.get_cells();
                for (var i = 0; i < nbb_cells.length; ++i) {
                    if (nbb_cells[i].input_prompt_number == nbb_cell_id) {
                        if (nbb_cells[i].get_text() == nbb_unformatted_code) {
                             nbb_cells[i].set_text(nbb_formatted_code);
                        }
                        break;
                    }
                }
            }, 500);
            
</script>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">class</span> <span class="nc">CoolSystem</span><span class="p">(</span><span class="n">pl</span><span class="o">.</span><span class="n">LightningModule</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">classes</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_hyperparameters</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">28</span> <span class="o">*</span> <span class="mi">28</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hparams</span><span class="o">.</span><span class="n">classes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_metric</span> <span class="o">=</span> <span class="n">Accuracy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">valid_metric</span> <span class="o">=</span> <span class="n">Accuracy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l1</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">training_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">batch</span>
        <span class="n">y_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">cross_entropy</span><span class="p">(</span><span class="n">y_hat</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">metric</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_metric</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">y_hat</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">log_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">train_loss</span><span class="o">=</span><span class="n">loss</span><span class="p">,</span> <span class="n">train_acc</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_dict</span><span class="p">(</span><span class="n">log_dict</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loss</span>

    <span class="k">def</span> <span class="nf">validation_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">batch</span>
        <span class="n">y_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">cross_entropy</span><span class="p">(</span><span class="n">y_hat</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">metric</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">valid_metric</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">y_hat</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">log_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">val_loss</span><span class="o">=</span><span class="n">loss</span><span class="p">,</span> <span class="n">val_acc</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_dict</span><span class="p">(</span><span class="n">log_dict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">configure_optimizers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.001</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">




<div id="bffac190-f4b8-4721-93df-65f2078f7045"></div>
<div class="output_subarea output_javascript ">
<script type="text/javascript">
var element = $('#bffac190-f4b8-4721-93df-65f2078f7045');

            setTimeout(function() {
                var nbb_cell_id = 10;
                var nbb_unformatted_code = "# slow\nclass CoolSystem(pl.LightningModule):\n    def __init__(self, classes=10):\n        super().__init__()\n        self.save_hyperparameters()\n        self.l1 = torch.nn.Linear(28 * 28, self.hparams.classes)\n        self.train_metric = Accuracy()\n        self.valid_metric = Accuracy()\n\n    def forward(self, x):\n        return torch.relu(self.l1(x.view(x.size(0), -1)))\n\n    def training_step(self, batch, batch_idx):\n        x, y = batch\n        y_hat = self(x)\n        loss = F.cross_entropy(y_hat, y)\n        metric = self.train_metric(F.softmax(y_hat), y)\n        log_dict = dict(train_loss=loss, train_acc=metric)\n        self.log_dict(log_dict)\n        return loss\n\n    def validation_step(self, batch, batch_idx):\n        x, y = batch\n        y_hat = self(x)\n        loss = F.cross_entropy(y_hat, y)\n        metric = self.valid_metric(F.softmax(y_hat), y)\n        log_dict = dict(val_loss=loss, val_acc=metric)\n        self.log_dict(log_dict)\n\n    def configure_optimizers(self):\n        return torch.optim.Adam(self.parameters(), lr=0.001)";
                var nbb_formatted_code = "# slow\nclass CoolSystem(pl.LightningModule):\n    def __init__(self, classes=10):\n        super().__init__()\n        self.save_hyperparameters()\n        self.l1 = torch.nn.Linear(28 * 28, self.hparams.classes)\n        self.train_metric = Accuracy()\n        self.valid_metric = Accuracy()\n\n    def forward(self, x):\n        return torch.relu(self.l1(x.view(x.size(0), -1)))\n\n    def training_step(self, batch, batch_idx):\n        x, y = batch\n        y_hat = self(x)\n        loss = F.cross_entropy(y_hat, y)\n        metric = self.train_metric(F.softmax(y_hat), y)\n        log_dict = dict(train_loss=loss, train_acc=metric)\n        self.log_dict(log_dict)\n        return loss\n\n    def validation_step(self, batch, batch_idx):\n        x, y = batch\n        y_hat = self(x)\n        loss = F.cross_entropy(y_hat, y)\n        metric = self.valid_metric(F.softmax(y_hat), y)\n        log_dict = dict(val_loss=loss, val_acc=metric)\n        self.log_dict(log_dict)\n\n    def configure_optimizers(self):\n        return torch.optim.Adam(self.parameters(), lr=0.001)";
                var nbb_cells = Jupyter.notebook.get_cells();
                for (var i = 0; i < nbb_cells.length; ++i) {
                    if (nbb_cells[i].input_prompt_number == nbb_cell_id) {
                        if (nbb_cells[i].get_text() == nbb_unformatted_code) {
                             nbb_cells[i].set_text(nbb_formatted_code);
                        }
                        break;
                    }
                }
            }, 500);
            
</script>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">CoolSystem</span><span class="p">()</span>

<span class="n">trainer</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">Trainer</span><span class="p">(</span>
    <span class="n">callbacks</span><span class="o">=</span><span class="p">[</span><span class="n">NotebookProgressCallback</span><span class="p">()],</span>
    <span class="n">checkpoint_callback</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">max_epochs</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">logger</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">trainer</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">mnist_train</span><span class="p">,</span> <span class="n">mnist_val</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>GPU available: False, used: False
TPU available: False, using: 0 TPU cores

  | Name         | Type     | Params
------------------------------------------
0 | l1           | Linear   | 7.9 K 
1 | train_metric | Accuracy | 0     
2 | valid_metric | Accuracy | 0     
------------------------------------------
7.9 K     Trainable params
0         Non-trainable params
7.9 K     Total params
0.031     Total estimated model params size (MB)
</pre>
</div>
</div>

<div class="output_area">


<div class="output_html rendered_html output_subarea ">

</div>

</div>

<div class="output_area">


<div class="output_html rendered_html output_subarea ">

    <div>
        <style>
            progress {
                border: none;
                background-size: auto;
            }
        </style>
      Training
      <progress value='18750' max='18750' style='width:300px; height:20px; vertical-align: middle;'></progress>
      [18750/18750 01:16, Epoch 9 {'loss': '1.54'}]
    </div>
    <table border="1" class="dataframe">
  <thead>
    <tr style="text-align: left;">
      <th>epoch</th>
      <th>val_loss</th>
      <th>val_acc</th>
      <th>train_loss</th>
      <th>train_acc</th>
      <th>time</th>
      <th>samples/s</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>1.591771</td>
      <td>0.460700</td>
      <td>1.512801</td>
      <td>0.531250</td>
      <td>7.752500</td>
      <td>282.232800</td>
    </tr>
    <tr>
      <td>1</td>
      <td>1.560491</td>
      <td>0.466600</td>
      <td>1.479620</td>
      <td>0.531250</td>
      <td>7.537000</td>
      <td>290.302500</td>
    </tr>
    <tr>
      <td>2</td>
      <td>1.546397</td>
      <td>0.469600</td>
      <td>1.458399</td>
      <td>0.531250</td>
      <td>7.280500</td>
      <td>300.529700</td>
    </tr>
    <tr>
      <td>3</td>
      <td>1.538233</td>
      <td>0.472000</td>
      <td>1.442020</td>
      <td>0.531250</td>
      <td>7.611100</td>
      <td>287.475700</td>
    </tr>
    <tr>
      <td>4</td>
      <td>1.533127</td>
      <td>0.471700</td>
      <td>1.434972</td>
      <td>0.500000</td>
      <td>7.621700</td>
      <td>287.076200</td>
    </tr>
    <tr>
      <td>5</td>
      <td>1.529259</td>
      <td>0.472400</td>
      <td>1.425169</td>
      <td>0.500000</td>
      <td>7.839900</td>
      <td>279.086400</td>
    </tr>
    <tr>
      <td>6</td>
      <td>1.526578</td>
      <td>0.472500</td>
      <td>1.418055</td>
      <td>0.500000</td>
      <td>7.444700</td>
      <td>293.901300</td>
    </tr>
    <tr>
      <td>7</td>
      <td>1.524461</td>
      <td>0.473600</td>
      <td>1.411882</td>
      <td>0.500000</td>
      <td>7.648000</td>
      <td>286.087900</td>
    </tr>
    <tr>
      <td>8</td>
      <td>1.522552</td>
      <td>0.473700</td>
      <td>1.404796</td>
      <td>0.500000</td>
      <td>7.651100</td>
      <td>285.971500</td>
    </tr>
    <tr>
      <td>9</td>
      <td>1.521521</td>
      <td>0.473400</td>
      <td>1.400422</td>
      <td>0.500000</td>
      <td>7.762100</td>
      <td>281.881000</td>
    </tr>
  </tbody>
</table><p>
</div>

</div>

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>1</pre>
</div>

</div>

<div class="output_area">




<div id="1ac06817-ca10-4adf-8e77-c02853b65bf8"></div>
<div class="output_subarea output_javascript ">
<script type="text/javascript">
var element = $('#1ac06817-ca10-4adf-8e77-c02853b65bf8');

            setTimeout(function() {
                var nbb_cell_id = 11;
                var nbb_unformatted_code = "# slow\nmodel = CoolSystem()\n\ntrainer = pl.Trainer(callbacks=[NotebookProgressCallback()], checkpoint_callback=False, \n                     max_epochs=10, logger=False)\n\ntrainer.fit(model, mnist_train, mnist_val)";
                var nbb_formatted_code = "# slow\nmodel = CoolSystem()\n\ntrainer = pl.Trainer(\n    callbacks=[NotebookProgressCallback()],\n    checkpoint_callback=False,\n    max_epochs=10,\n    logger=False,\n)\n\ntrainer.fit(model, mnist_train, mnist_val)";
                var nbb_cells = Jupyter.notebook.get_cells();
                for (var i = 0; i < nbb_cells.length; ++i) {
                    if (nbb_cells[i].input_prompt_number == nbb_cell_id) {
                        if (nbb_cells[i].get_text() == nbb_unformatted_code) {
                             nbb_cells[i].set_text(nbb_formatted_code);
                        }
                        break;
                    }
                }
            }, 500);
            
</script>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

</div>
 

