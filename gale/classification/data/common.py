# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/05_classification.data.common.ipynb (unless otherwise specified).

__all__ = ['pil_loader', 'cv2_loader', 'ClassificationMapper']

# Cell
import logging
from typing import *

import albumentations as A
import cv2
import numpy as np
import torch
import torchvision.transforms as T
from albumentations.pytorch import ToTensorV2
from fastcore.all import *
from PIL import Image
from timm.data.constants import *
from timm.data.transforms import ToNumpy

from ...core.classes import Configurable

_logging = logging.getLogger(__name__)

# Cell
def pil_loader(path: str) -> Image.Image:
    """
    Loads in a Image using PIL
    """
    im = Image.open(path).convert("RGB")
    return im

# Cell
def cv2_loader(path: str) -> np.ndarray:
    """
    Loads in a Image using cv2
    """
    im = cv2.imread(path)
    im = cv2.cvtColor(im, cv2.COLOR_BGR2RGB)
    return im

# Cell
@typedispatch
def convert_image(image: Image.Image):
    return np.array(image)

# Cell
@typedispatch
def convert_image(image: np.ndarray):
    return Image.fromarray(image)

# Cell
@typedispatch
def load_and_apply_image_transforms(path: str, transforms: A.Compose):
    image = cv2_loader(path)
    aug_image = transforms(image=image)
    return aug_image["image"]

# Cell
@typedispatch
def load_and_apply_image_transforms(path: str, transforms: T.Compose):
    image = pil_loader(path)
    aug_image = transforms(image)
    return aug_image

# Cell
@typedispatch
def load_and_apply_image_transforms(path: str, transforms: None):
    return pil_loader(path)

# Cell
class ClassificationMapper(DisplayedTransform):
    decodes = noop
    """
    A callable which takes in a dataset and map it into a format used by the model.
    This mapper takes in a Dict/str as input . The key "file_name" must contain the
    path to the Image to be loaded and key "target" must contain the integer target.

    The callable currently does the following:
    1. Reads in the image from `file_name`.
    2. Applies transformations to the Images
    3. Converts dataset to return `torch.Tensor` Images & `torch.long` targets

    You can also optionally pass in `xtras` these which must be a callable functions. This function
    is applied after converting the images to to tensors. Helpfull for applying trasnformations like
    RandomErasing which requires the inputs to be tensors.
    """

    def __init__(
        self,
        augmentations: Optional[Union[T.Compose, A.Compose]] = None,
        mean: Sequence[float] = IMAGENET_DEFAULT_MEAN,
        std: Sequence[float] = IMAGENET_DEFAULT_STD,
        xtras: Optional[Callable] = noop,
    ):
        """
        Arguments:
        1. `augmentations`: a list of augmentations or deterministic transforms to apply
        2. `mean`, `std`: list or tuple with #channels element, representing the per-channel mean and
        std to be used to normalize the input image. Note: These should be normalized values.
        4. `xtras`: A callabcle funtions applied after images are normalized and converted to tensors.
        """
        store_attr()
        self.np_conversion = ToNumpy()

        # fmt: off
        self.normalize = T.Compose([
            T.ToTensor(),
            T.Normalize(torch.tensor(self.mean), torch.tensor(self.std)),
        ])
        # fmt: on

    def encodes(self, dataset_dict: Dict):
        """
        Arguments:
        1. dataset_dict: A Dictionary containing the "file_name" and "target"

        Returns : Tuple containing `images (torch.Tensor)` and `targets (torch.FloatTensor)`.
        Note - that the Images are returned in CHW format
        """
        # fmt: off
        image = load_and_apply_image_transforms(dataset_dict["file_name"], self.augmentations)
        # fmt: on
        image = self.normalize(image)
        image = self.xtras(image)

        assert isinstance(image, torch.Tensor)

        target = dataset_dict["target"]
        target = torch.tensor(target, dtype=torch.long)
        return image, target

    def encodes(self, image_path: str):
        """
        Arguments:
        1. image_path: a str contraining the path of the Images

        Returns: `images (torch.Tensor)`. Note - that the Images are returned in CHW format
        """
        image = load_and_apply_image_transforms(image_path, self.augmentations)
        image = self.normalize(image)
        image = self.xtras(image)

        assert isinstance(image, torch.Tensor)
        return image